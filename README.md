# DesignPatterns
使用java 把23种常见的设计模式进行学习一遍

## 一、什么是设计模式

&emsp;&emsp;设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。
模式：在某些场景下，针对某类问题的某种通用的解决方案。
场景：项目所在的环境
问题：约束条件，项目目标等
解决方案：通用、可复用的设计，解决约束达到目标。

## 二、模式的分类
- 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。

- 结构型模式：把类或对象结合在一起形成一个更大的结构。

- 行为型模式：类和对象如何交互，及划分责任和算法。

## 三、各个分类中模式的关键点

1.单例模式（连接服务器操作等）：某个类只能有一个实例，提供一个全局的访问点。

2.简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。

3.工厂方法（加减乘除计算器）：定义一个创建对象的接口，让子类决定实例化那个类。通常设计应该从工厂方法
开始，当发现需要更大的灵活性时，设计便会向其他创建型模式演化。

4.抽象工厂(例如同一个对象使用不同数据库)：创建相关或依赖对象的家族，而无需明确指定具体类。

5.建造者模式（创建一个人物形象）：封装一个复杂对象的构建过程，并可以按步骤构造。内聚性描述的是一个
例程内部组成部分之间相互联系的紧密程度。
而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程，内部完整
，也就是高内聚，而与其他例程之间联系则是小巧，直接，可见，灵活的，这就是松耦合。

6.原型模式（简历修改，深拷贝和浅拷贝）：通过复制现有的实例来创建新的实例。
	
--- 

A.适配器模式（例如翻译）：将一个类的方法接口转换成客户希望的另外一个接口。可以让接口不同的类
通过适配后协同工作。

B.组合模式（例如公司代理与总公司层次结构）：将对象组合成树形结构以表示“”部分-整体“”的层次结构。
组合模式的效果是，客户可以一致地使用组合结构和单个对象，任何用到基本对象的地方都可以使用组合对象。

C.装饰模式（人物换衣功能）：动态的给对象添加新的功能。装饰过程就是一条链表

D.代理模式（类似中介）：为其他对象提供一个代理以便控制这个对象的访问。代理和外观主要区别在于，
代理对象代表一个单一对象而外观对象代表一个子系统。代理的客户无法直接访问目标对象，由代理
提供单独的目标对象的访问控制。而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象
提供子系统各元件功能的简化的共同层次的调用接口。

&emsp;&emsp; 代理和适配器的区别在于，代理还是一种原来对象的代表，其他需要与这个对象打交道的操作都
是和这个代表交涉。而适配器则不需要虚构出一个代表，只需要为应付特定使用目的，将原来的类进行一些组合。


E.亨元（蝇量）模式（围棋对象创建）：通过共享技术来有效的支持大量细粒度的对象。比如文档处理
软件。当中的字符都可以是对象，如果让文档中的每个字符都是一个对象的话，会产生难以接受的开销
这时可以考虑使用享元模式。

F.外观模式（用户通过机构购买股票）：对外提供一个统一的方法，来访问子系统中的一个接口。
如果两个类不必彼此直接通信，那么就不要让这两个类发生直接的相互作用。类之间的耦合越弱，
越有利于复用。一个处在弱耦合的类被修改，不会对有关系的类造成波及。通常企业软件的三层或
N层架构，层与层之间分离其实就是外观模式的体现。

G. 桥接模式（软件可以在不同硬件上运行）：将抽象部分和它的实现部分分离，使它们都可以独立的变化。不一样
的解耦方式，用聚合代替继承，通过对象组合的方式，将两个角色之间的继承关系改为了组合的关系，从而使这
两者可以应对各自独立的变化。


####适配器模式、外观模式、桥接模式再比较：
1. 适配器模式：主要是为了解决两个已有接口之间不匹配的问题，他不需要考虑这些接口是怎样实现的，
也不考虑他们各自可能会如何演化，他这种方式不需要对两个独立设计的类中任一个进行重新设计，就能够使他们
协同工作。
2. 桥接模式：和适配器模式类似都具有一些共同的特征，就是给另一对象提供一定程度的间接性，这样有利于系统
的灵活性，桥接模式通常是在设计之初，就对抽象接口与它的实现部分进行桥接，让抽象与实现两者可以独立
演化。
3. 外观模式：桥接模式和适配器模式是用于软件声明周期的不同阶段，针对不同的问题，谈不上孰优孰劣。
外观定义的是一个新的接口，而适配器则是复用一个原有的接口，适配器是使两个已有的接口协同工作，
而外观则是为现存系统提供一个更为方便的访问接口。换句话说，适配器是用来适配对象的，而外观模式
是用来适配整个子系统的。


---
a. 模板模式（例如试卷回答）：定义一个算法结构，而将一些步骤延迟到子类实现。代码重复是编程中最常见、最
糟糕的。当你继承一个类时，派生类马上就可以获得基类中所有的功能，当然也可以在它的基础上任意增加新的功能。
模板方法模式是由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板方法。每个从这个
抽象类派生的具体类将为此模板实现新的方法。所有可重复的代码都提炼到抽象类中了。这就是代码的复用。

b. 解释器模式(例如正则表达式，就是描述字符串模式的一种标准语言)：给定一个语言，定义它的文法的一种表示，并定义一个解释器。

c. 策略模式（超市做打折，正常收费，满减活动）：定义一系列算法，把他们封装起来，并且使它们可以相互替换。
该模式使得算法可独立于使用它的客户而变化。
继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类A的子类B、C、D、，从而给它以不同
的行为。但这样会将行为硬行编制到父类A当中，而将算法的实现与 类A的实现混合起来。从而使得类A难以理解，难以维护
和难以扩展，而且还不能动态的改变算法。它们之间的唯一差别是他们所使用的算法或行为，将算法封装在
独立的策略类中使得你可以独立于其类A改变它，使他易于切换、易于理解、易于扩展。这里显然使用对象组合要
优于类继承。

d. 状态模式（工作时间，不同的时间不同的状态）：允许一个对象在其对象内部状态改变时改变它的行为。
状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的if 或switch
中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中。所以通过定义
新的子类可以很容易地增加新的状态或转换。

e. 观察者模式（例如放哨）：对象间的一对多的依赖关系。主要是解除对象之间的紧耦合关系

f. 备忘录模式（例如闯关游戏复活）：在不破坏封装的前提下，保持对象的内部状态。并在该对象之外保存这个状态，
这样以后就可将该对象恢复到原先保存的状态。
备忘录模式把可能很复杂的对象A的内部信息对其他对象隐蔽起来，从而保持了封装边界

g. 中介者模式（例如联合国安全理事会）：用一个中介对象来封装一系列的对象交互。
中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。
将集体行为封装一个单独的中介者对象来避免这个问题，中介者负责控制和协调一组对象间的交互，中介者充当
一个中介以使组中的对象不再相互显示引用。这些对象仅知道中介者，从而减少了相互连接的数目。

h. 命令模式（餐厅点菜）：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。将请求发送者
具体实现者分离，这样可以在不同的时刻指定、排列和执行请求。可以支持事务操作。

i. 访问者模式（例如男女对同一件事的不同反应）：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。
访问者增加具体的Element 是困难的，但增加依赖于复杂对象结构的构件的操作就变的很容易。仅需增加一个新的访问者
即可在一个对象结构上定义一个新的操作。

j. 责任链模式（例如向上级请假）：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。
有多个对象可以处理一个请求，哪个对象处理该请求事先并不知道，要在运行时刻自动确定，这时最好的方法就是
让请求发送者与具体处理者分离。让客户在不明确指定接收者的情况下，提交一个请求。然后由所有
能处理这请求的对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

k. 迭代器模式（常用的 Map for each 操作）：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
迭代器模式的关键思想是将对类别的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义一个
访问该列表元素的接口，迭代器对象负责跟踪当前元素，并且知道哪些元素已经遍历过了。

---
迪米特法则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，
如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
这个法则要求：在类的结构设计上，每一个类都应当尽量降低成员的访问权限。
其根本思想是：它强调了类之间的松耦合。

在程序设计过程中，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的
类造成波及。

UML类图说明：

- 一个矩形框代表一个类，类图分三层，第一层显示类的名称，如果是抽象类，则会用斜体显示。
第二层是类的特性，通常是字段和属性，第三层是类的操作，通常是方法或行为。
注意前面的符号，'+' 表示 public ，'-' 表示 private，’#‘表示 protected

- 与类图类似的是接口图，它们主要区别是接口图顶端有 《interface》 显示，第一行是接口名称，
第二行是接口方法，还有另一种表示方法俗称棒棒糖表示法。

- 类与接口之间的关系，继承关系用空心三角形+实线来表示，实现接口用空心三角形+虚线表示

- 当一个类 “知道” 另一个类时，可以用关联表示，关联关系用实线箭头表示（比如企鹅和气候）

- 聚合表示一种弱的“拥有”关系，体现是A对象可以包含B对象，但B对象不是A对象的一部分
（如大雁和雁群就满足聚合关系），聚合关系用空心的菱形+实线箭头

- 组合表示一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样
（如鸟和它的翅膀就是组合关系）合成关系用实心的菱形+实线箭头，联系两端还有数字，这被称为
基数。表明这一端的类可以有几个实例。关联关系和聚合关系也可以有基数。

- 比如动物有几大特征，比如新陈代谢，能繁殖，而动物要有生命力，需要氧气，水及食物等。
也就是说，动物依赖于氧气和水，他们之间是依赖关系，用虚箭头表示。

## 总结
 在创建对象是，使用抽象工厂、原型、建造者的设计比使用工厂方法要更灵活，但她们也更加负责，通常
 设计时是以使用工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型
 模式演化。工厂方法的实现并不能减少工作量，但是它能够在必须处理新情况时，避免使已经很复杂
 的代码更加复杂。